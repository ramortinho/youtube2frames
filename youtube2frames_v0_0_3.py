# -*- coding: utf-8 -*-
"""youtube2frames-v0.0.3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VUXzZ16UjeTWhEvYTLd87TaQyORuVgMq
"""

# BLOCO PARA DOWNLOAD DO VÍDEO NA RESOLUÇÃO INDICADA COM LIMPEZA DE CONTEÚDO, MANTENDO PASTAS

import os
import yt_dlp
import shutil

# Definir o caminho base do projeto
base_dir = "/content/project"
download_dir = os.path.join(base_dir, "downloaded")

# Função para limpar o conteúdo das pastas, mantendo a estrutura e sem deletar a pasta YOLO
def limpar_conteudo_pastas():
    for root, dirs, files in os.walk(base_dir):
        for file in files:
            file_path = os.path.join(root, file)
            if "yolo" not in root:  # Evitar deletar conteúdo dentro da pasta YOLO
                os.remove(file_path)  # Remove o arquivo
        for dir in dirs:
            dir_path = os.path.join(root, dir)
            if "yolo" not in dir_path and os.path.exists(dir_path):
                shutil.rmtree(dir_path)  # Remove a pasta e seu conteúdo
    os.makedirs(download_dir, exist_ok=True)  # Recriar a pasta de downloads vazia

# Limpar o conteúdo das pastas
limpar_conteudo_pastas()

# Defina a resolução como uma variável configurável
resolucao = 1080  # Pode ser 720, 1080, 1440, 2160, etc.

# Opções do yt-dlp para baixar o vídeo com base na resolução escolhida e usar o ID como nome
ydl_opts = {
    'format': f'bestvideo[height<={resolucao}]+bestaudio/best[height<={resolucao}]',
    'outtmpl': os.path.join(download_dir, '%(id)s.%(ext)s')  # Salvar o vídeo no diretório definido
}

# Baixar o vídeo e capturar o nome do arquivo baixado
with yt_dlp.YoutubeDL(ydl_opts) as ydl:
    result = ydl.extract_info('https://www.youtube.com/watch?v=v8jNVa-Edik', download=True)
    video_filename = f"{result['id']}.{result['ext']}"  # Nome do arquivo baixado

print(f"Vídeo baixado e salvo em: {os.path.join(download_dir, video_filename)}")

# BLOCO PARA EXTRAIR FRAMES DO VÍDEO USANDO O NOME DINÂMICO DO ARQUIVO

import cv2
import os

# Definir o caminho base do projeto e a pasta de vídeos baixados
base_dir = "/content/project"
download_dir = os.path.join(base_dir, "downloaded")
output_dir = os.path.join(base_dir, "frames", "frames_extraidos")

# Garantir que o diretório para frames extraídos exista
os.makedirs(output_dir, exist_ok=True)

# Definir o caminho correto do vídeo baixado (nome do vídeo é uma variável agora)
video_path = os.path.join(download_dir, video_filename)  # Usar o nome do arquivo baixado

# Carregar o vídeo usando OpenCV
cap = cv2.VideoCapture(video_path)

# Definir o intervalo de extração de frames (a cada 30 frames = 1 segundo em vídeos de 30 fps)
frame_interval = 30
frame_count = 0
saved_frame_count = 0

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break  # Final do vídeo

    # Extrair um frame a cada 'frame_interval'
    if frame_count % frame_interval == 0:
        # Salvar o frame extraído no diretório de saída
        frame_filename = os.path.join(output_dir, f"frame_{saved_frame_count}.jpg")
        cv2.imwrite(frame_filename, frame)
        saved_frame_count += 1

    frame_count += 1

cap.release()
cv2.destroyAllWindows()

print(f"Frames extraídos e salvos em: {output_dir}")

# ESTE BLOCO FILTRA FRAMES COM BASE NA NITIDEZ E SALVA APENAS OS FRAMES NÍTIDOS

import cv2
import os

# Função para calcular a nitidez da imagem
def calcular_nitidez(frame):
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)  # Converter para escala de cinza
    laplacian_var = cv2.Laplacian(gray, cv2.CV_64F).var()  # Calcular variância do Laplaciano
    return laplacian_var

# Definir o caminho base do projeto e diretórios de frames
base_dir = "/content/project"
frames_dir = os.path.join(base_dir, "frames", "frames_extraidos")
filtered_dir = os.path.join(base_dir, "frames", "frames_filtrados")

# Garantir que o diretório para frames filtrados exista
os.makedirs(filtered_dir, exist_ok=True)

# Definir limite de nitidez (threshold). Ajuste conforme o tipo de vídeo.
threshold_nitidez = 50.0  # Ajustado para vídeos da GoPro, pode variar de 50.0 a 75.0

# Verificar cada frame extraído e aplicar filtragem de nitidez
for frame_file in os.listdir(frames_dir):  # Processar frames extraídos
    frame_path = os.path.join(frames_dir, frame_file)
    frame = cv2.imread(frame_path)

    # Calcular a nitidez
    nitidez = calcular_nitidez(frame)

    if nitidez > threshold_nitidez:  # Apenas salvar frames com nitidez acima do limite
        filtered_frame_path = os.path.join(filtered_dir, frame_file)
        cv2.imwrite(filtered_frame_path, frame)

print(f"Frames nítidos salvos em: {filtered_dir}")

# BLOCO PARA DETECÇÃO DE OBJETOS ESPECÍFICOS USANDO YOLOv3 COM CRIAÇÃO DE DIRETÓRIO YOLO

import cv2
import os
import numpy as np

# Definir o caminho base do projeto e pastas para YOLO e frames
base_dir = "/content/project"
yolo_dir = os.path.join(base_dir, "yolo")
filtered_dir = os.path.join(base_dir, "frames", "frames_filtrados")
objects_dir = os.path.join(base_dir, "frames", "frames_com_objetos")

# Garantir que o diretório para armazenar frames com objetos detectados e o diretório YOLO existam
os.makedirs(objects_dir, exist_ok=True)
os.makedirs(yolo_dir, exist_ok=True)  # Criar o diretório para os arquivos YOLO

# Baixar automaticamente os arquivos YOLO se não estiverem presentes na pasta yolo_dir
yolo_cfg_path = os.path.join(yolo_dir, "yolov3.cfg")
yolo_weights_path = os.path.join(yolo_dir, "yolov3.weights")

if not os.path.exists(yolo_cfg_path):
    print("Baixando yolov3.cfg...")
    !wget -O {yolo_cfg_path} https://raw.githubusercontent.com/pjreddie/darknet/master/cfg/yolov3.cfg

if not os.path.exists(yolo_weights_path):
    print("Baixando yolov3.weights...")
    !wget -O {yolo_weights_path} https://pjreddie.com/media/files/yolov3.weights

# Verificar se os arquivos foram baixados corretamente
if not os.path.exists(yolo_cfg_path) or not os.path.exists(yolo_weights_path):
    raise FileNotFoundError(f"YOLO files not found in {yolo_dir}. Please check the paths and download process.")

# Carregar o modelo YOLO a partir do diretório especificado
net = cv2.dnn.readNet(yolo_weights_path, yolo_cfg_path)
layer_names = net.getLayerNames()
output_layers = [layer_names[i - 1] for i in net.getUnconnectedOutLayers()]

# Lista completa de classes que YOLOv3 pode detectar (80 classes do dataset COCO)
classes_interesse = list(range(80))  # IDs de 0 a 79 para todas as classes suportadas pelo YOLOv3

# Função para detectar objetos
def detectar_objetos(frame):
    height, width, channels = frame.shape
    blob = cv2.dnn.blobFromImage(frame, 0.00392, (416, 416), (0, 0, 0), True, crop=False)
    net.setInput(blob)
    outs = net.forward(output_layers)

    objetos_detectados = []
    for out in outs:
        for detection in out:
            scores = detection[5:]
            class_id = np.argmax(scores)
            confidence = scores[class_id]
            if confidence > 0.5 and class_id in classes_interesse:  # Confiança de detecção > 50% e classe de interesse
                objetos_detectados.append(class_id)

    return frame, len(objetos_detectados) > 0  # Retorna o frame e se algum objeto foi detectado

# Processar frames filtrados
for frame_file in os.listdir(filtered_dir):
    frame_path = os.path.join(filtered_dir, frame_file)
    frame = cv2.imread(frame_path)

    frame_com_objetos, objetos_detectados = detectar_objetos(frame)

    if objetos_detectados:
        cv2.imwrite(os.path.join(objects_dir, frame_file), frame_com_objetos)

print(f"Frames com objetos salvos em: {objects_dir}")

# BLOCO PARA ESCOLHER OS MELHORES FRAMES POR CENA

import cv2
import numpy as np
import os
import shutil  # Para limpar a pasta

# Definir o caminho base do projeto e diretórios
base_dir = "/content/project"
filtered_dir = os.path.join(base_dir, "frames", "frames_filtrados")
unique_dir = os.path.join(base_dir, "frames", "frames_unicos")

# Apagar os dados da pasta frames_unicos antes de iniciar
if os.path.exists(unique_dir):
    shutil.rmtree(unique_dir)  # Remove todos os arquivos da pasta
os.makedirs(unique_dir, exist_ok=True)  # Recriar a pasta vazia

# Função para calcular a diferença entre dois frames usando a diferença de pixels
def calcular_diferenca(frame1, frame2):
    diff = cv2.absdiff(frame1, frame2)
    gray = cv2.cvtColor(diff, cv2.COLOR_BGR2GRAY)
    _, thresh = cv2.threshold(gray, 30, 255, cv2.THRESH_BINARY)
    return np.sum(thresh)

# Função alternativa para calcular a diferença usando histogramas
def calcular_diferenca_histograma(frame1, frame2):
    hist1 = cv2.calcHist([frame1], [0, 1, 2], None, [8, 8, 8], [0, 256, 0, 256, 0, 256])
    hist2 = cv2.calcHist([frame2], [0, 1, 2], None, [8, 8, 8], [0, 256, 0, 256, 0, 256])
    hist1 = cv2.normalize(hist1, hist1).flatten()
    hist2 = cv2.normalize(hist2, hist2).flatten()
    # Comparar os histogramas
    return cv2.compareHist(hist1, hist2, cv2.HISTCMP_CORREL)

# Função para calcular a nitidez
def calcular_nitidez(frame):
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    laplacian_var = cv2.Laplacian(gray, cv2.CV_64F).var()
    return laplacian_var

# Variável de limiar para definir o quanto dois frames devem diferir para serem considerados únicos
threshold_correlacao = 0.90  # Ajuste para a correlação do histograma (1.0 significa idêntico)

previous_frame = None
melhor_frame = None
melhor_nitidez = 0
previous_frame_file = None  # Para manter o nome original do frame

# Processar frames filtrados
for frame_file in sorted(os.listdir(filtered_dir)):  # Ordenar para manter sequência
    frame_path = os.path.join(filtered_dir, frame_file)
    frame = cv2.imread(frame_path)

    if previous_frame is None:
        previous_frame = frame
        melhor_frame = frame
        melhor_nitidez = calcular_nitidez(frame)
        previous_frame_file = frame_file  # Salvar o nome original do primeiro frame
    else:
        # Usar histograma para comparar frames
        correlacao = calcular_diferenca_histograma(previous_frame, frame)

        if correlacao < threshold_correlacao:  # Se a correlação for baixa, frames são diferentes
            # Salvar o melhor frame do grupo anterior
            cv2.imwrite(os.path.join(unique_dir, previous_frame_file), melhor_frame)

            # Atualizar para o novo grupo de frames
            previous_frame = frame
            melhor_frame = frame
            melhor_nitidez = calcular_nitidez(frame)
            previous_frame_file = frame_file  # Atualizar o nome do novo grupo

        else:  # Se os frames forem semelhantes, escolher o mais nítido
            nitidez_atual = calcular_nitidez(frame)
            if nitidez_atual > melhor_nitidez:
                melhor_nitidez = nitidez_atual
                melhor_frame = frame
                previous_frame_file = frame_file  # Atualizar o nome do melhor frame

# Garantir que o último melhor frame seja salvo
if melhor_frame is not None:
    cv2.imwrite(os.path.join(unique_dir, previous_frame_file), melhor_frame)

print(f"Frames únicos e com melhor nitidez salvos em: {unique_dir}")

import shutil
from google.colab import files

# Definir o caminho base do projeto e os diretórios das pastas a serem compactadas
base_dir = "/content/project"
output_dir = os.path.join(base_dir, "frames", "frames_extraidos")
filtered_dir = os.path.join(base_dir, "frames", "frames_filtrados")
objects_dir = os.path.join(base_dir, "frames", "frames_com_objetos")
unique_dir = os.path.join(base_dir, "frames", "frames_unicos")

# Criar diretório para armazenar os arquivos zipados
zip_dir = os.path.join(base_dir, "zipped")
os.makedirs(zip_dir, exist_ok=True)

# Compactar as pastas de frames em arquivos zipados
# shutil.make_archive(os.path.join(zip_dir, 'frames_extraidos'), 'zip', output_dir)
# shutil.make_archive(os.path.join(zip_dir, 'frames_filtrados'), 'zip', filtered_dir)
# shutil.make_archive(os.path.join(zip_dir, 'frames_com_objetos'), 'zip', objects_dir)
shutil.make_archive(os.path.join(zip_dir, 'frames_unicos'), 'zip', unique_dir)
# shutil.make_archive(os.path.join(zip_dir, 'frames_com_rostos'), 'zip', faces_dir)

# Mostrar os links para download
# files.download(os.path.join(zip_dir, 'frames_extraidos.zip'))
# files.download(os.path.join(zip_dir, 'frames_filtrados.zip'))
# files.download(os.path.join(zip_dir, 'frames_com_objetos.zip'))
files.download(os.path.join(zip_dir, 'frames_unicos.zip'))
# files.download(os.path.join(zip_dir, 'frames_com_rostos.zip'))